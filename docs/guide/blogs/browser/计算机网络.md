# 计算机网络

## OSI/RM 基本参考模型（由ISO国际标准化组织制定）

- **应用层**（Application）  -- 最高层（第7层）
- **表示层**（Presentation）
- **会话层**（Session）
- **传输层**（Transport）
- **网络层**（NetWork）
- **数据链路层**（DataLink）
- **物理层**（Physical）        -- 最底层（第1层）

<img src="/images/jiwang/terminal-connect.png" alt="终端连接" style="zoom: 50%;" />

- 数据封装过程（解封装过程正好相反）

<img src="D:\WorkSpace\前端\Git\myBlog\docs\.vuepress\public\images\jiwang\terminal-connect2.png" alt="数据封装过程" style="zoom: 50%;" />



## 物理层（Physical）

### 目的

- 保证原始数据**比特流**的无误传输

### 任务

- 确定与物理媒体相关的**电气特性**、**机械特性**、**功能特性**及**规程特性**
  1. 机械特性：连接器的形式与插针分配
  2. 电气特性：接口电气信号特性
  3. 功能特性：数据传送、控制、定时、接地
  4. 规程特性：接口电路所使用的**规程**(规定多长的高低电平表示多少个1、0)

### 带宽

- **带宽定义**：每秒钟传输的数字比特`bit`
- **下载速率**：每秒钟传输的`字节数`
- 带宽的单位：bps(比特率),即 `bit/sec`
- **注意：**带宽的单位和文件的单位不同。
  1. **带宽的大小**：指的是`每秒能吞吐多少个'位'`(0/1)
  2. **文件的大小**：指的是`1字节 = 8位(bit)` (8个0/1)
- **网络距离与带宽**
  - 距离与带宽成**反比**，距离越远，带宽越低
  - 因此：局域网的带宽比广域网大

### 设备

- 线路（网线、光纤、无线、同轴电缆）、网卡
- **双绞线**可以降低两根线上生成的**磁场**对**信号**产生的影响（电信号）
- **单模光纤**的**带宽**比**多模光纤**更大（光信号）
- **无线：**
  - 蓝牙（传输速率低、距离短）
  - 红外（不能有遮挡）
  - RFID（射频技术--NFC）
- **网卡（网络适配器）：**
  - **功能**：
    1. 将数字信号进行`串/并转换`（属于**物理层**的功能）
    2. 地址标识（属于**数据链路层**的功能）
    3. 数据帧的封装和拆卸（属于**数据链路层**的功能）
  - **网卡地址（无法更改）**
    - 每个网卡都有字节的`MAC地址`,又叫**网卡地址**，48比特长，0-23位是厂商代码，24-47位是厂商自行分配的地址
    - `ipconfig/all`查询所有网卡地址（包括物理地址和IP地址）



## 数据链路层（DataLink）

### 目的

- 保证**数据**（`单位：帧`）在物理链路上实现**可靠**的传输
  1. 数据的封装和拆卸
  2. 地址标识
  3. 数据校验

### 设备

- 主要是**交换机**



## 网络层（NetWork）

### 目的

- 实现数据跨网络的链家
- 传输单位`包`

### 功能

- **路由选择**

- **实现数据跨网络的连接**（网线+交换机+路由器）

- **IP协议**

  - 图示

  <img src="/images/jiwang/IPxieyi.png" alt="IP协议" style="zoom:80%;" />

  - **Ping命令**：使用ICMP协议，可以查看网络连接是否正常
    - 使用：`ping address`
    - 参数：
      - `-t ` 一直ping下去，只有手动停止
      - `-l 数据包大小  `  指定数据包大小
    - ping不通的原因：
      1. 线路松动或者断开
      2. 网卡问题：网卡坏了、网卡驱动问题
      3. IP地址问题：地址错误、或者不在同一网络中，并且没有路由等

- **IP地址**

  - **IPv4地址**由`32位`二进制数字组成，通常将每八位转换为十进制展示（192.168.0.1),范围为`0-255`，255是广播地址、0表示网段
  - **IP地址**由**网络号**和**主机号**组成(`各16位`)
  - **网络号** = **IP** 与 **子网掩码**     (以**二进制**运算)
  
- **物理层+数据链路层+网络层：实现数据从源主机的网卡 送到 目标主机的网卡中**

- **物理层+数据链路层+网络层+传输层：实现数据从源主机的进程 送到 目标主机的应用进程**（端口号）



## 传输层（Transport）

### 目的

- 实现数据从源进程到目标主机进程的传输
- 断点续传
- 拥塞控制

### 协议

- **UDP**协议

  - 用户数据报协议
  - 不可靠的、无连接的协议
  - 传输效率高
  - 没有流控机制，只有校验和来提供差错控制（需要上层协议来提供差错控制-例如：TFTP协议）

- **TCP**协议

  - 传输控制协议

  - 可靠的、面向连接的协议

  - 传输效率低

    

- UDP和TCP协议的区别：

  1. UDP是**无连接**的协议，TCP是**面向连接**的协议
  2. TCP比UDP协议更可靠
  3. UDP比TCP相比要占用的网络开销小很多，更经济

- **TCP段的格式**

  - **源端口**和**目标端口**

  - **序号**(`占4个字节`)（sequence number）：数据段的号码

  - **确认序号**(`占4个字节`)（ack number）：确认序号 = 收到的数据的序号 + 1

    - 表示对方可以发送下一个数据的序列号
    - ACK 是否确认消息：`1:确认消息   0：非确认消息`

  - **SYN**: 发送给对方的第一个消息

  - **FIN**：发送给对方的最后一个消息

  - 图示：

    <img src="/images/jiwang/TCP格式.png" alt="TCP图示" style="zoom: 80%;" />

  



### TCP连接-三次握手

- **主机A**向**主机B**发送`SYN`，请求建立连接

- **主机B**向**主机A**发送`SYN、ACK=1`,表示同意建立连接，并请求与主机A建立连接

- **主机A**向**主机B**发送`ACK=1`,表示同意建立连接，至此三次握手完成

  <img src="/images/jiwang/TCP-connect.png" alt="TCP连接" style="zoom:80%;" />



### TCP连接-四次挥手

- **主机A**向**主机B**发送`FIN=1`，表示数据传输完毕，请求断开连接

- **主机B**向**主机A**发送`ACK=1`，表示收到该次请求，但此时数据可能还没接收完

- **主机B**向**主机A**发送`FIN=1`,表示数据接收完毕，请求断开连接

- **主机A**向**主机B**发送`ACK=1`，同意断开连接, 至此四次挥手完成

  <img src="/images/jiwang/TCP-unConnect.png" alt="TCP连接-四次挥手" style="zoom:80%;" />





## 应用层（Application）

- 决定数据传输格式、是否加密、压缩等

## 应用层-TCP/IP协议栈

- 图示

  <img src="/images/jiwang/App-xieyi.png" style="zoom:80%;" />



## 应用层常见协议

###  HTTP协议（HyperText  Transfer  Protocol）超文本传输协议

- 请求响应式协议，请求和响应有固定的格式
  - **请求格式**：
    - **请求行**：用来说明请求类型,要访问的资源以及所使用的HTTP版本。GET说明请求类型为GET，最后一部分说明使用的是HTTP1.1版本。
  - **请求头**：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息，从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等
    - **空行**：请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须有空行。
    - **请求体**：可以添加任意的其他数据
  - **响应格式**：**响应行**、**响应头**、**空行**、**响应体**
  
- 请求方式
  - get
  - post
  - delete
  - patch
  - ...
- 请求响应状态码
  - 1xx  通常表示正在处理中、处理未完成
  - 2xx  通常表示**正常**返回
  - 3xx  通常表示**重定向**
  - 4xx  通常表示**客户端**错误
  - 5XX 通常表示**服务器**错误



### DNS协议（Domain  Name  System）域名服务系统

- DNS域名系统，用于**TCP/IP网络**，是和HTTP一样位于**应用层**的协议，它所提供的服务是用来**将主机名和域名转换为IP地址**的工作。

- 域名介绍：

  - 每台服务器都会有一个自己**特有**的标识来和其它服务器区分，这就是IP地址(例如192.168.0.1) ，因此我们访问服务器时都是通过**IP地址**来访问的，但是我们可以看到IP地址极其不利于记忆，因此后面推出了域名，它相当于是服务器的别名，因此访问服务器时我们可以通过域名来访问，但是最终访问服务器的本质还是将域名进行DNS解析，然后通过ip地址来访问的

- DNS工作图示

  <img src="/images/jiwang/DNS.png" style="zoom:80%;" />

- DNS层次结构图示

  <img src="/images/jiwang/DNS-cengci.png" style="zoom: 80%;" />

- DNS递归查询图示

  ![DNS递归查询图示](/images/jiwang/DNS-chaxun.png)

- DNS迭代查询图示

  ![DNS迭代查询图示](/images/jiwang/DNS-chaxun-diedai.png)



## HTTP1.1和HTTP2.0的特点

- HTTP1.1
  - 默认**持久连接**节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求 。
  - 管线化，客户端可以**同时发出多个HTTP请求**，而不用一个个等待响应 。
  - **断点续传**，就是可以将一个大数据，分段传输，客户端可以慢慢显示

- HTTP2.0
  - HTTP2.0 采用**二进制格式**而非文本格式
  - HTTP2.0 是**完全多路复用**的，而非有序并阻塞的——只需一个HTTP连接就可以实现多个请求响应
  - 使用**报头压缩**，HTTP2.0 降低了开销
  - HTTP2.0 让**服务器**可以将响应**主动**“**推送**”到**客户端缓存中**



## Cookie和Session的区别

### Cookie

- **情景说明**：
  - HTTP协议是**无状态协议**，它不对之前发生过的请求和响应的状态进行管理。也就是说，**无法根据之前的状态进行本次的请求处理**。假设登录认证的Web页面本身无法进行状态的管理(即不记录已登录状态)，那么每次跳转刷新页面的话**不是要**再次登录，**就是要**在每次请求的报文中附加参数来管理登录状态了。
  - 当然，**无状态协议**也有它**的优点**，由于**不必保存状态**，自然而然的**减少了服务器的CPU和内存资源**，也正是因为**无状态协议的优点**才使得HTTP协议被广泛应用，那么**如何实现即保留无状态协议、又要解决类似的矛盾问题就成为了一个非常重要的问题**，在这样的背景下，**Cookie技术**诞生了！

- Cookie技术**通过在请求和响应报文中写入Cookie信息来控制客户端的状态**。

  1. 它会根据从服务器发送的响应报文内的一个叫做`Set-Cookie`的首部字段信息，通知客户端保存Cookie。

  2. 当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

  3. 服务器端发现客户端发送过来的Cookie后，会检查究竟是从哪一个客户端发送来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

### Session

- **Cookie是客户端自己保存用户信息的一种机制**，而**Session却是将先前的用户信息记录在服务器端**，并且生成一个唯一的**Session-ID**,这样一来客户端在每次访问时就仅仅只需提供对应的ID号码便可从服务器获取先前存储的对应信息
- **Session的典型应用场景**：
  - 以**购物车场景**为例，当用户点击下单按钮时，由于HTTP是**无状态协议**，所以它并不知道是哪个用户在操作，所以服务器要为**特定的用户**创建了**特定的Session**，用于**标识这个用户，并同时跟踪用户**，这样才能保存当前用户的购物信息。而这个Session是存储在**服务器**的，有一个**唯一的Session-ID**与之对应。
- **服务器保存Session的手段**:
  - 服务器可以将Session保存在内存、数据库、文件等等。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候Session信息都是放在内存的，会使用一些缓存服务比如Memcached之类的来存放Session



### 总结

- cookie数据存放在客户的浏览器上，session数据存放在服务器上
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie
- 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K





## HTTPS

- HTTPS就是安全的HTTP，在http与传输层之间加上了一个SSL对称加密与非对称加密。HTTPS = HTTP+ 加密 + 认证 + 完整性保护



## 浏览器中输入一个URL发生什么?

- 输入URL： http://www.taobao.com
- **DNS域名解析**，获取到域名对应的**IP地址**和**端口号**
- **建立TCP/IP连接**(三次握手)
- 将用户输入的**URL地址封装到请求报文中**发送到服务器
- 服务器将**请求的结果封装到响应报文中**发送到客户端
- **客户端接收到响应数据后开始渲染页面**(解析HTML、CSS、执行JS代码)





